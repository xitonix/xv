package commands

import (
	"bufio"
	"fmt"
	"log"
	"math/rand"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/alecthomas/kingpin/v2"
)

const (
	letterIdxBits = 6                    // 6 bits to represent a letter index
	letterIdxMask = 1<<letterIdxBits - 1 // All 1-bits, as many as letterIdxBits
	letterIdxMax  = 63 / letterIdxBits
)

type initKey struct {
	key     string
	appName string
}

func setupKey(app *kingpin.Application) {
	cmd := &initKey{
		appName: app.Name,
	}
	kCmd := app.Command("init", fmt.Sprintf(`Initialises a new key file (eg. %s init [Encryption Key])`, app.Name)).Action(cmd.run)
	kCmd.Arg("key", fmt.Sprintf("Encryption key (Minimum length: %d). A random key will be generated if not specified.", keySize)).
		StringVar(&cmd.key)
}

func (c *initKey) run(_ *kingpin.ParseContext) error {
	key := strings.TrimSpace(c.key)
	var autoGenerated bool
	if len(key) == 0 {
		key = randomKey()
		autoGenerated = true
	}
	if len(key) < keySize {
		return errKeyTooSmall
	}
	home, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("Failed to get home directory. %w", err)
	}
	path := filepath.Join(home, "."+c.appName)
	if _, err = os.Stat(path); err == nil {
		if !askForConfirmation(fmt.Sprintf("The key file '%s' already exists. Overwrite", path)) {
			return nil
		}
	}
	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("Failed to create the key file %s. %w", path, err)
	}
	defer func() {
		if err = f.Close(); err != nil {
			log.Printf("Failed to close key file: %v", err)
		}
	}()
	if _, err = f.WriteString(key); err != nil {
		return fmt.Errorf("Failed to write key file %s. %w", path, err)
	}
	fmt.Printf("The key file %s has been created successfully", path)
	if autoGenerated {
		fmt.Printf("\nEncryption key: %s\n%s %sMAKE SURE TO STORE THE KEY IN A SAFE PLACE%s", key, emojiWarn, colourYellow, ColourReset)
	}

	return nil
}

func askForConfirmation(question string) bool {
	scanner := bufio.NewScanner(os.Stdin)
	msg := fmt.Sprintf("%s [y/n]?: ", question)
	for fmt.Print(msg); scanner.Scan(); fmt.Print(msg) {
		r := strings.ToLower(strings.TrimSpace(scanner.Text()))
		switch r {
		case "y", "yes":
			return true
		case "n", "no", "q", "quit", "exit":
			return false
		}
	}
	return false
}

func randomKey() string {
	const source = "123456789@#$!&*%/()[]{}<>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@#$!&*%/()[]{}<>123456789"
	rndSource := rand.NewSource(time.Now().UnixNano())
	sb := strings.Builder{}
	sb.Grow(keySize)
	for i, cache, remain := keySize-1, rndSource.Int63(), letterIdxMax; i >= 0; {
		if remain == 0 {
			cache, remain = rndSource.Int63(), letterIdxMax
		}
		if idx := int(cache & letterIdxMask); idx < len(source) {
			sb.WriteByte(source[idx])
			i--
		}
		cache >>= letterIdxBits
		remain--
	}

	return sb.String()
}
